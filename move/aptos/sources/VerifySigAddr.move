module VerifySigAddr::Verify{

    use 0x1::ed25519;
    use 0x1::string;
    use std::hash;
    use 0x1::bcs;

    // use 0x1::hash;
    // use 0x1::option;
    // use 0x1::type_info;
    
    // public fun get_signed_message_hash32(vector<u8> message) vector<u8> {
    //     // https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/framework/aptos-stdlib/doc/secp256k1.md
    //     return ecdsa_signature_from_bytes(message): secp256k1::ECDSASignature // Possibly useful
    //     // return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", message));
    // }

    // public fun get_message_hash(
    //     oracle_name: address,
    //     memory asset_pair_id: string::String, // No string type in move :(, meant to be vector
    //     timestamp: u128, // u128 is the biggedst type, no 256
    //     price: u128,
    // ) vector<u8> {
    //     // return keccak256(abi.encodePacked(oracle_name, asset_pair_id, timestamp, price));
    // }

    // public fun get_signer(
    //     signed_message_hash: vector<u8>,
    //     r: vector<u8>, // is bytes32 a vector?
    //     s: vector<u8>,
    //     v: u8
    // ) address {
    //     // does signature need to be constructed to match the given type?
    //     return ecdsa_recover(signed_message_hash, recovery_id: u8, signature: &secp256k1::ECDSASignature)
    // }


    public fun verify_signature(        
        oracle_pubkey: vector<u8>,
        // asset_pair_id: string::String, // No string type in move :(, meant to be vector
        // timestamp: u128, // u128 is the biggest type, no 256
        // price: u128,
        signature: vector<u8>,
        // message: vector<u8>
        // r: vector<u8>, // is bytes32 a vector?
        // s: vector<u8>,
        // v: u8
    ) : bool {
        // let oracle_bytes = bcs::to_bytes(&oracle_pubkey);

        let oracle_string = bcs::to_bytes(&string::utf8(b"0xf1a1a7a5706732b8026e5ccc5811b3392b3efbb6c7fa09e513b09f7bfe38edfd"));
        let asset_pair_id = bcs::to_bytes(&string::utf8(b"ETHUSD"));
        let price = bcs::to_bytes(&1472980000000000000000u128);
        let timestamp = bcs::to_bytes(&1663309101u128);

        let prefix = hash::sha3_256(b"APTOS::RawTransaction");

        std::vector::append(&mut oracle_string, asset_pair_id);
        std::vector::append(&mut oracle_string, timestamp);
        std::vector::append(&mut oracle_string, price);

        let bcs_hashed = hash::sha3_256(oracle_string);

        std::vector::append(&mut prefix, bcs_hashed);

        let sig = ed25519::new_signature_from_bytes(signature);
        let public_key = ed25519::new_unvalidated_public_key_from_bytes(oracle_pubkey);

        return ed25519::signature_verify_strict(&sig, &public_key, prefix)

        

        // vector<u8> msg_hash = get_message_hash(oracle_pubkey, asset_pair_id, timestamp, price);
        // vector<u8> signed_message_hash = get_signed_message_hash32(msg_hash);

        // // Verify hash was generated by the actual user
        // address signer = get_signer(signed_message_hash, r, s, v);
        // return (signer == oracle_pubkey) ? true : false

    }
    
}

